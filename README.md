# Psychedelic Experience

Stripped down source code of my Psychedelic Experience project (PEx). PEx was a comprehensive online resource surrounding psychedelic substances and plants.


This is the .NET backend published in a new repo without sensitive data, a git history rewrite was too much work unfortunately.
It was under development from 2015 to 2021, it stayed online until 2022...


**It's for code viewing only, the packages are out of date and the client (react) app isn't published (yet) because I tried to run it again fom a clean repro and ended up in node/npm/tsc hell...**


Main features:
- Organisations and reviews: organisation diectory with review system for 800+ retreat centers, research organisations, clinics, individual practicioners, ...
- Organisation Events: Organisations could publish their events (retreats, community events, ...)
- Survey for Thank You Plant Medicine
- Experiences: publish psychedelic experience reports online (not in ui anymomre)
- OAuth flow with fb and google integration (partially broken by now), user profiles, notifications, syncrhronisation with external systems


Tech:
- .net core, asp.net, c#
- js/ts, react (with server-side rendering)
- Postgres/Marten document DB
- Clean Code/DDD/CQRS/Event Sourcing/Projections
- Behavior-driven Development
- Code generation based on a simple dsl for events, commands, value type, ... (*.gl) Generation tool is in the Tools folder.


Key takeaways:
- Sensitive data: don't put sensitive data (passwords, emails, api keys) in your git repositories. People are running scripts to extract it, even in the history. Also when it's a private, you never know who is watching ;-)
- Code: Seems I was in a hurry sometimes, some file names are wrong. Some files contain too many unrelated classes, or only comments. It's is a bit inconsistent, posted as is :-)
- MartinDB: I used the event projections to synchronize data with different external systems and to send emails. Projections can be monitored and rebuild via api (AdminController). It works in this case. A messagebus would have been necessary at some point.
- Event sourcing: I created a view model per aggregate to query from the UI generated by a projection. I wouldn't start with this, querying the latest snapshot will do for a looong time in most cases.
- Event sourcing: I don't see a reason to 'event source' the aggregates (anymore). I don't dislike the design of the aggregates, but the command and event handler could be a single method if the aggregates wouldn't be 'event sourced'. And the single table event-store would have been the first bottleneck to solve performance wise. Raising the events from the aggregate still feels right, and the (event sourced) projections are definitly a huge advantage.
- CQRS: Since the domain is very document centric, I was thinking a lot of the aggregates and command handlers could be developed in a more declarative way. Same for most controller actions. Maybe one day ;-)
